---
layout: default
title: Testing
---

# Testing Strategy #
Our team approached Testing using a combination of Unit Testing, Integration Testing, and UI Testing. We used JUnit with Mockito framework for Unit Testing and Espresso for UI Testing. However, there were many challenges in the testing process due to the complexity of the application, and we were not able to finalize the testing process.

# Unit  Testing #
Because our app heavily relied on the interactions between different objects, we decided to use JUnit with Mockito framework for Unit Testing, because it allowed us to mock the objects and test the interactions between them. Regarding Unit testing the ML features of the app, we found this quite difficult to do, due the specific nature of the ML integration. As such, we created a test class for each class in the app, and we tested the methods in each class, however, there were a lot of bugs in the process, and after long sessions of troubleshootings with no improvements, we decided to focus on other features as we were not able to finalize the testing process. However, We were able to create unit tests for the ActivitySenior class, where each of the helper functions were tested alongside testing the broadcast receiver. The LivePreviewActivity class was also tested in this manner. It is quite difficult to provide accurate results of test coverage as we are using multiple SDKs, that in order to test to some degree, require Mockito. However, we cannot directly test them, there are two main ways to test the interactions of these SDKs: using mock tests, that mock the behaviour and check that the actual classes are being called. For example within the ActivitySeniorTest we have tested whether our activity is actually able to call the launch Jitsi function or whehter the setMeetingValue is called correctly through the broadcast receiver. These are valid unit testing methods but are unable to be recognised by testing coverage frameworks. The second method is integration testing through instrumented tests, we go into this in the next section.

# UI and Integration Testing #
For the UI testings, recorded Espresso tests were used. We created a test class for each activity in the app, and we tested the interactions between the different views in the app. Our tests covered all the pages of the app and the interactions between them, with all tests passing successfully for API version 30 to 34. This UI testing can also be considered integration testing due to the nature of of our project. As being able to integrate the viewfinder and model into the same application and being able to see their interactions via UI testing allows us to confirm that they have been integrated to the app to a degree. We attempted to create UI and integration testing for the Jitsi SDK integration, however, there seems to be a bug in the way espressor records the interaction of an SDK making it quite difficult to implement.
